package day2.SortAlgorithms;

/**
 * 冒泡排序
 * 每次排序把最大的冒泡到最后
 * 冒泡排序第一层循环为需要对多少个数据进行排序
 *       第二层循环是每次把最大的冒泡到最后需要多少次
 * 数组的后半部分总是有序，前半部分无序
 */
public class MaoPaoSort {

    public static void main(String[] agrs) {
        int[] a = new int[]{54, 21, 6, 4, 56, 1, 13, 45, 131, 5};
        Test.maopao(a);
        MaoPao(a);
    }

    /**
     * [10,1,35,61,89,36,55]为例子
     * 每趟排序把最大的冒泡到最后去
     * 第一趟排序：
     *          第一次排序：10和1比较，10大于1，交换位置 　　 　  [1,10,35,61,89,36,55]
     *          第二次排序：10和35比较，10小于35，不交换位置　　  [1,10,35,61,89,36,55]
     *          第三次排序：35和61比较，35小于61，不交换位置　　  [1,10,35,61,89,36,55]
     *          第四次排序：61和89比较，61小于89，不交换位置　　[1,10,35,61,89,36,55]
     *          第五次排序：89和36比较，89大于36，交换位置　　　[1,10,35,61,36,89,55]
     *          第六次排序：89和55比较，89大于55，交换位置　　　[1,10,35,61,36,55,89]
     * 这样就完成了第一次排序，把89冒泡到了最后
     * @param arr
     */
    public static void MaoPao(int[] arr) {
        // 一共需要对n-1个元素进行排序
        for (int i = 0; i < arr.length-1; i++) {
            // 每一趟排序需要比较的次数
            for (int j = 0; j < arr.length - i -1 ; j++) {
                if (arr[j] > arr[j+1]) {
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
    }
}
